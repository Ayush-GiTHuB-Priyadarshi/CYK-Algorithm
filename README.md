# The Cocke-Kasami-Younger Algorithm 

## Overview
This repository provides an implementation of the Cocke-Kasami-Younger (CKY) algorithm, a dynamic programming approach for determining whether a given string can be generated by a context-free grammar (CFG). The algorithm operates in cubic time (O(n³)) with respect to the length of the input string, making it significantly more efficient than brute-force derivation checking.

## Background
The CKY algorithm solves the membership problem for context-free languages: given a CFG G and a string x, does x ∈ L(G)? The algorithm works by:
1. Converting the grammar to Chomsky Normal Form (CNF)
2. Systematically checking all possible ways to derive substrings of x
3. Building a parse table to track which nonterminals can generate each substring

## Algorithm Details

### Input Requirements
- A CFG in Chomsky Normal Form (productions of form A → BC or A → a)
- An input string x ∈ Σ*

### Data Structures
The algorithm uses an n×n table T where:
- n = length of input string x
- T[i][j] contains all nonterminals that can generate the substring x[i..j]

### Steps
1. **Initialization**: Fill diagonal entries (substrings of length 1)
   - For each terminal a at position i, add all A where A → a
2. **Inductive Step**: For substrings of length l = 2 to n:
   - For all possible splits of the substring into two parts
   - Combine nonterminals using productions A → BC
3. **Final Check**: If start symbol S ∈ T[0][n-1], x ∈ L(G)

## Example Grammar
The provided example grammar generates strings with equal numbers of 'a's and 'b's:
```
S → AB | BA | SS | AC | BD
A → a
B → b
C → SB
D → SA
```

## Example Execution
For input string "aabbab":
1. Initialize table with length-1 substrings
2. Fill in longer substrings by combining smaller ones
3. Final table shows S can generate the entire string

## Complexity Analysis
- Time: O(n³) for string length n
- Space: O(n²) for the parse table

## Implementation Notes
The algorithm is particularly efficient because:
1. It avoids recomputation by storing intermediate results
2. It systematically checks all possible derivations without redundancy
3. The CNF restriction ensures each derivation step either produces a terminal or exactly two nonterminals

## References
1. Cocke, J. and Schwartz, J.T. (1970). "Programming languages and their compilers: Preliminary notes".
2. Kasami, T. (1965). "An efficient recognition and syntax-analysis algorithm for context-free languages".
3. Younger, D.H. (1967). "Recognition and parsing of context-free languages in time n³".
4. The main reference being Lecture 27 from Kozen's book on Automata & Computability.
