# The Cocke-Kasami-Younger Algorithm 

## Overview
This repository provides an implementation of the Cocke-Kasami-Younger (CKY) algorithm, a dynamic programming approach for determining whether a given string can be generated by a context-free grammar (CFG). The algorithm operates in cubic time (O(n³)) with respect to the length of the input string, making it significantly more efficient than brute-force derivation checking.

## Background
The CKY algorithm solves the membership problem for context-free languages: given a CFG G and a string x, does x ∈ L(G)? The algorithm works by:
1. Converting the grammar to Chomsky Normal Form (CNF)
2. Systematically checking all possible ways to derive substrings of x
3. Building a parse table to track which nonterminals can generate each substring

## Algorithm Details

### Input Requirements
- A CFG in Chomsky Normal Form (productions of form A → BC or A → a)
- An input string x ∈ Σ*

### Data Structures
The algorithm uses an n×n table T where:
- n = length of input string x
- T[i][j] contains all nonterminals that can generate the substring x[i..j]

### Steps
1. **Initialization**: Fill diagonal entries (substrings of length 1)
   - For each terminal a at position i, add all A where A → a
2. **Inductive Step**: For substrings of length l = 2 to n:
   - For all possible splits of the substring into two parts
   - Combine nonterminals using productions A → BC
3. **Final Check**: If start symbol S ∈ T[0][n-1], x ∈ L(G)

## Example Grammar
The provided example grammar generates strings with equal numbers of 'a's and 'b's:
```
S → AB | BA | SS | AC | BD
A → a
B → b
C → SB
D → SA
```

## Example Execution
For input string "aabbab":
1. Initialize table with length-1 substrings
2. Fill in longer substrings by combining smaller ones
3. Final table shows S can generate the entire string

## Complexity Analysis
- Time: O(n³) for string length n
- Space: O(n²) for the parse table

## Implementation Notes
The algorithm is particularly efficient because:
1. It avoids recomputation by storing intermediate results
2. It systematically checks all possible derivations without redundancy
3. The CNF restriction ensures each derivation step either produces a terminal or exactly two nonterminals

## References
1. Cocke, J. and Schwartz, J.T. (1970). "Programming languages and their compilers: Preliminary notes".
2. Kasami, T. (1965). "An efficient recognition and syntax-analysis algorithm for context-free languages".
3. Younger, D.H. (1967). "Recognition and parsing of context-free languages in time n³".
4. The main reference being Lecture 27 from Kozen's book on Automata & Computability.

Here's a comprehensive README.md for your GitHub repository:

## Implementation Details

### Core Components

1. **CFG Class** (in `helpers.py`):
   - Parses production rules from string input
   - Implements the CYK algorithm to check if a string can be generated by the grammar
   - Handles both terminal and non-terminal productions
   - Supports grammars in Chomsky Normal Form (CNF)

2. **Graph Class** (in `helpers.py`):
   - Maintains an adjacency list representation of the graph
   - Supports labeled edges (important for string generation)
   - Provides methods for edge addition and retrieval

3. **Main Algorithm** (in `main.py`):
   - Reads input from file with multiple test cases
   - For each test case:
     - Builds the CFG from production rules
     - Constructs the graph from edge data
     - Checks all possible paths between start and end nodes
     - Verifies if any path generates a string accepted by the CFG
   - Writes results to output file

### Algorithm Workflow

1. **Input Parsing**:
   - Reads number of test cases
   - For each case, extracts:
     - CFG production rules
     - Graph edge data
     - Start and end vertices

2. **Graph Exploration**:
   - Uses BFS to explore all paths from start to end vertex
   - Constructs strings from edge labels along each path

3. **CFG Validation**:
   - For each generated string, applies CYK algorithm
   - Checks if string can be derived from the CFG

4. **Result Generation**:
   - Outputs "Yes" if any valid path exists
   - Outputs "No" otherwise

## How to Use

### Input Format

Create an `input.txt` file with the following format:
```
<number_of_test_cases>
<CFG_productions>
<graph_edges>
<start_vertex>
<end_vertex>
...
```

Example:
```
2
S->AB;A->a;B->b
A b B,A a A,B b B,B a A
A
B
S->AB|BA;A->a;B->b
A b B,A a A
A
B
```

### Running the Program

```bash
python main.py
```

This will:
1. Read from `input.txt`
2. Process all test cases
3. Write results to `output.txt`

### Output Format

The `output.txt` will contain one line per test case with "Yes" or "No":
```
Yes
No
```

## Grammar Analysis and CNF Conversion

### Original Grammar (Non-CNF)
The grammar was originally specified as:
```
S → aSbb | T
T → bTaa | S | ε
```

### Conversion to Chomsky Normal Form (CNF)
The grammar was converted to CNF (without ε-productions) as:
```
S → LY | BR | AY | BZ
L → AS
R → SZ
A → a
B → b
Z → AA
Y → BB
```

### Accepted Case (4th input):
```
PQ:a PR:a RT:a QT:a QS:b YA:a SV:a VW:a WZ:b ZA:b TU:a UX:a XY:a
P
A
```

### Rejected Case (5th input):
```
PQ:b PR:a RT:a QT:a QS:b YA:a SV:a VW:a WZ:b ZA:b TU:a UX:a XY:a
P
S
```
  
Note - The code takes care of the looping case by rejecting it as in 1st 

## Technical Details

### CYK Algorithm Implementation

The CYK algorithm works by:
1. Creating a triangular parse table
2. Filling the diagonal with terminals
3. Building up the table by combining non-terminals
4. Checking if the start symbol appears in the top cell

### Graph Traversal

- Uses Breadth-First Search (BFS) to explore all paths
- Tracks both the current node and accumulated string
- Efficiently handles cycles by focusing on string generation

## Limitations

1. The CFG must be in Chomsky Normal Form
2. Graph cycles can lead to infinite string generation (currently handled by focusing on complete paths)

## Future Improvements

1. Implement grammar conversion to CNF
2. Add a bound on length to be checked and implement it avoiding the infinite cycle issue.
3. Add visualization for parse tables and graph paths.
